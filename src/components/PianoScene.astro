---
// src/components/ThreeScene.astro
---
<div id="three-canvas-container"></div>

<style>
    #three-canvas-container {
        width: 100%;
        height: 100%;
        min-height: 1250px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: visible;
    }
</style>

<script>
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PIANO_KEYS } from '../constants/melodies';
    import gsap from 'gsap';
    import { ScrollTrigger } from 'gsap/ScrollTrigger';

    gsap.registerPlugin(ScrollTrigger);

    let isZoomedIn = false; 
    let isAnimating = false; // Flag para saber se o GSAP está a correr
    let currentPanLimit = 4; // Começamos com o limite de zoom-out

    const container = document.getElementById('three-canvas-container')!;
    let width = container.clientWidth;
    let height = container.clientHeight;

    // --- 1. SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0d0d0d, 0.02);

    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(0, 30, 30); // Subir (Y=15) e Afastar (Z=15)
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    // --- ORBIT CONTROLS ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    
    // --- LIMITES DE ROTAÇÃO (ALARGADOS PARA PERMITIR RESISTÊNCIA) ---
    controls.minPolarAngle = Math.PI / 20;   
    controls.maxPolarAngle = Math.PI / 1.5; 
    controls.minAzimuthAngle = -Math.PI / 4; 
    controls.maxAzimuthAngle = Math.PI / 4;  
    
    const BASE_ROTATE_SPEED = 1.0;
    controls.rotateSpeed = BASE_ROTATE_SPEED;

    // Limites de Translação (Pan) e Zoom
    controls.enablePan = true;   
    controls.enableZoom = false;
    controls.keyPanSpeed = 7.0; 

    // Bloqueio fixo de Y e Z no pan (Botão Direito)
    // Deixamos a lógica de limites apenas para o animate() para ser síncrona com a renderização
    controls.addEventListener('change', () => {
        if (controls.target.y !== 0 || controls.target.z !== 0) {
            const dy = controls.target.y;
            const dz = controls.target.z;
            camera.position.y -= dy;
            camera.position.z -= dz;
            controls.target.y = 0;
            controls.target.z = 0;
        }
    });

    // --- 2. LIGHTS ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); 
    scene.add(ambientLight);

    const spotLight = new THREE.SpotLight(0xddeeff, 10);
    spotLight.position.set(-10, 20, 10);
    spotLight.angle = Math.PI / 6;
    spotLight.penumbra = 0.5;
    spotLight.castShadow = true;
    spotLight.shadow.bias = -0.0001;
    scene.add(spotLight);

    const rimLight = new THREE.DirectionalLight(0xffffff, 1);
    rimLight.position.set(0, 10, -10);
    scene.add(rimLight);

    // --- 3. MATERIALS ---
    const whiteKeyMat = new THREE.MeshPhysicalMaterial({
        color: 0x010101, // Mantendo extremamente escuro
        roughness: 0.4,   // Mais baço para difundir a luz
        metalness: 0.0,
        clearcoat: 0.3,   // Um brilho subtil por cima
        clearcoatRoughness: 0.4,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
    });

    const blackKeyMat = new THREE.MeshPhysicalMaterial({
        color: 0x010101,
        roughness: 0.05,  // Muito liso, quase espelhado
        metalness: 0.8,   // Aspeto mais metálico/ebony
        clearcoat: 1.0,   // Brilho intenso
        clearcoatRoughness: 0.0,
    });

    const wireframeMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });

    const allKeys: (THREE.Group | THREE.Mesh)[] = []; // Array para guardar as teclas

    const caseMat = new THREE.MeshPhysicalMaterial({
        color: 0x050505,
        roughness: 0.2,
        metalness: 0.8,
        clearcoat: 0.5,
    });

    const feltMat = new THREE.MeshBasicMaterial({ color: 0x050505 });

    // --- 4. KEYBOARD GROUP ---
    const keyboardGroup = new THREE.Group();
    scene.add(keyboardGroup);

    // --- 5. CONFIGURATION ---
    const NUM_WHITE_KEYS = 52; // Standard for 88 keys
    const GAP = 0.04;
    
    // White Keys
    const WHITE_KEY_WIDTH = 1.0; 
    const WHITE_KEY_HEIGHT = 1.0;
    const WHITE_KEY_LENGTH_FRONT = 2.2; 
    const WHITE_KEY_LENGTH_BACK = 4.4;  
    const WHITE_KEY_LENGTH_TOTAL = WHITE_KEY_LENGTH_FRONT + WHITE_KEY_LENGTH_BACK;
    
    const LIP_THICKNESS = 0.08; 
    const LIP_DEPTH = 0.07; 

    // Black Keys
    const BLACK_KEY_WIDTH = 0.52;
    const BLACK_KEY_LENGTH = 3.75;
    const BLACK_KEY_HEIGHT = 0.55; 
    const BLACK_KEY_CUTOUT_WIDTH = 0.6; // For the notch in white keys
    // Helper para as Brancas
    function createKeyShape(type: number, frontOffset = 0, isFirst = false, isLast = false) {
        const shape = new THREE.Shape();
        const w = WHITE_KEY_WIDTH - GAP;
        const cutoutW = BLACK_KEY_CUTOUT_WIDTH;
        
        let cL = 0, cR = 0; 
        
        // Se for a primeira tecla (A0), não tem recorte à esquerda
        // Se for a última (C8), não tem recorte à direita
        if (!isFirst && !isLast) {
            switch(type) {
                case 0: case 3: cR = cutoutW * 0.6; break;
                case 2: case 6: cL = cutoutW * 0.6; break;
                case 1: cL = cutoutW * 0.35; cR = cutoutW * 0.35; break;
                case 4: cL = cutoutW * 0.3; cR = cutoutW * 0.45; break;
                case 5: cL = cutoutW * 0.45; cR = cutoutW * 0.3; break;
            }
        } else if (isFirst) {
            // A0: Só tem recorte à direita para o A#0
            cR = cutoutW * 0.6; 
        } else if (isLast) {
            // C8: Não tem recortes (é uma tecla retangular no topo)
            // Mantemos cL e cR em 0
        }

        shape.moveTo(0, frontOffset);
        shape.lineTo(w, frontOffset);
        shape.lineTo(w, WHITE_KEY_LENGTH_FRONT);
        shape.lineTo(w - cR, WHITE_KEY_LENGTH_FRONT);
        shape.lineTo(w - cR, WHITE_KEY_LENGTH_TOTAL);
        shape.lineTo(cL, WHITE_KEY_LENGTH_TOTAL);
        shape.lineTo(cL, WHITE_KEY_LENGTH_FRONT);
        shape.lineTo(0, WHITE_KEY_LENGTH_FRONT);
        shape.lineTo(0, frontOffset);
        return shape;
    }

    function createWhiteKeyGroup(type: number, isFirst = false, isLast = false) {
        const group = new THREE.Group();
        const bodyH = WHITE_KEY_HEIGHT - LIP_THICKNESS;

        const bodyGeo = new THREE.ExtrudeGeometry(createKeyShape(type, LIP_DEPTH, isFirst, isLast), { steps: 1, depth: bodyH + 0.02, bevelEnabled: false });
        bodyGeo.rotateX(-Math.PI / 2);
        bodyGeo.translate(0, 0, WHITE_KEY_LENGTH_TOTAL); // Move o pivô para trás
        const bodyMesh = new THREE.Mesh(bodyGeo, whiteKeyMat);
        bodyMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(bodyGeo), wireframeMat));
        group.add(bodyMesh);

        const topGeo = new THREE.ExtrudeGeometry(createKeyShape(type, 0, isFirst, isLast), { steps: 1, depth: LIP_THICKNESS, bevelEnabled: false });
        topGeo.rotateX(-Math.PI / 2);
        topGeo.translate(0, bodyH, WHITE_KEY_LENGTH_TOTAL); // Move o pivô para trás
        const topMesh = new THREE.Mesh(topGeo, whiteKeyMat);
        topMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(topGeo), wireframeMat));
        group.add(topMesh);

        return group;
    }

    // --- BLACK KEY ---
    function createBlackKey() {
        const shape = new THREE.Shape();
        const r = 0.06; 
        const hW = BLACK_KEY_WIDTH / 2;
        const hL = BLACK_KEY_LENGTH / 2;

        shape.moveTo(-hW, hL);
        shape.lineTo(hW, hL);
        shape.lineTo(hW, -hL + r);
        shape.quadraticCurveTo(hW, -hL, hW - r, -hL);
        shape.lineTo(-hW + r, -hL);
        shape.quadraticCurveTo(-hW, -hL, -hW, -hL + r);
        shape.lineTo(-hW, hL);

        const geo = new THREE.ExtrudeGeometry(shape, { depth: BLACK_KEY_HEIGHT, bevelEnabled: false, steps: 1 });
        geo.rotateX(-Math.PI / 2);
        geo.translate(0, 0, WHITE_KEY_LENGTH_TOTAL - BLACK_KEY_LENGTH/2 - WHITE_KEY_LENGTH_FRONT); // Alinha o pivô com as brancas

        const pos = geo.attributes.position;
        const slopeZ = 0.3; 

        for (let i = 0; i < pos.count; i++) {
            const y = pos.getY(i);
            const z = pos.getZ(i);
            const t = Math.max(0, Math.min(1, y / BLACK_KEY_HEIGHT));
            const taperFactor = 1.0 - (t * 0.35);
            pos.setX(i, pos.getX(i) * taperFactor);
            if (z > -WHITE_KEY_LENGTH_TOTAL + 1.0) { 
                pos.setZ(i, z - t * slopeZ);
            }
        }
        geo.computeVertexNormals();

        const mesh = new THREE.Mesh(geo, blackKeyMat);
        mesh.position.y = WHITE_KEY_HEIGHT;
        mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo, 20), wireframeMat));
        
        return mesh;
    }

    const TOTAL_WIDTH = NUM_WHITE_KEYS * WHITE_KEY_WIDTH;

    // Adjustments for black key centering on the seams
    const blackKeyAdjustments: Record<number, number> = {
        1: -0.09, // C#
        2:  0.07, // D#
        4: -0.1,  // F#
        5: -0.01, // G#
        6:  0.07  // A#
    };

    for (let i = 0; i < NUM_WHITE_KEYS; i++) {
        const isFirst = (i === 0);
        const isLast = (i === NUM_WHITE_KEYS - 1);
        
        const noteIndex = (i + 5) % 7;
        const xPos = (i * WHITE_KEY_WIDTH) - (TOTAL_WIDTH / 2);

        // Place White Key
        const wk = createWhiteKeyGroup(noteIndex, isFirst, isLast);
        wk.position.set(xPos, 0, -WHITE_KEY_LENGTH_TOTAL);
        wk.userData.isWhite = true;
        wk.userData.index = i; // Guardamos o índice para identificar o Dó Central
        keyboardGroup.add(wk);
        allKeys.push(wk);

        // Place Black Key if applicable
        const hasBlackKeyAfter = [5, 0, 1, 3, 4].includes(noteIndex);
        if (hasBlackKeyAfter && !isLast) {
            const bk = createBlackKey();
            const bkIndex = noteIndex + 1;
            const shift = blackKeyAdjustments[bkIndex] || 0;
            bk.position.x = xPos + WHITE_KEY_WIDTH + shift;
            bk.position.z = -WHITE_KEY_LENGTH_TOTAL;
            bk.userData.isWhite = false;
            keyboardGroup.add(bk);
            allKeys.push(bk);
        }
    }

    // --- Case / Frame Parts ---
    const blockWidth = 2.5;
    const blockGeo = new THREE.BoxGeometry(blockWidth, WHITE_KEY_HEIGHT + 0.5, WHITE_KEY_LENGTH_TOTAL + 2);
    const leftBlock = new THREE.Mesh(blockGeo, caseMat);
    leftBlock.position.set(-TOTAL_WIDTH/2 - blockWidth/2, 0.25, -WHITE_KEY_LENGTH_TOTAL/2 + 0.5);
    const rightBlock = new THREE.Mesh(blockGeo, caseMat);
    rightBlock.position.set(TOTAL_WIDTH/2 + blockWidth/2 - GAP, 0.25, -WHITE_KEY_LENGTH_TOTAL/2 + 0.5);
    keyboardGroup.add(leftBlock, rightBlock);

    const keyslipGeo = new THREE.BoxGeometry(TOTAL_WIDTH + blockWidth * 2, 1.0, 1.5);
    const keyslip = new THREE.Mesh(keyslipGeo, caseMat);
    keyslip.position.set(-0.35, -0.4, 0.6);
    keyboardGroup.add(keyslip);

    const fallboardGeo = new THREE.BoxGeometry(TOTAL_WIDTH + blockWidth * 2, 4, 1);
    const fallboard = new THREE.Mesh(fallboardGeo, caseMat);
    fallboard.position.set(-0.35, 2, -WHITE_KEY_LENGTH_TOTAL - 0.5);
    keyboardGroup.add(fallboard);

	const feltGeo = new THREE.BoxGeometry(TOTAL_WIDTH + blockWidth, 0.1, 0.5);
    const felt = new THREE.Mesh(feltGeo, feltMat);
    felt.position.set(-WHITE_KEY_WIDTH/2, WHITE_KEY_HEIGHT, -WHITE_KEY_LENGTH_TOTAL + 0.2);
    keyboardGroup.add(felt);

	// --- ANIMATION ---
    const mouse = { x: 0 };
    window.addEventListener('mousemove', (e) => {
        // Normaliza a posição do mouse entre -1 e 1
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    });

    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        // Mantemos o efeito de flutuar
        keyboardGroup.position.y = Math.sin(time * 0.5) * 0.15;

        // Movimento subtil do piano seguindo o rato
        const groupTargetX = -mouse.x * 3; 
        keyboardGroup.position.x += (groupTargetX - keyboardGroup.position.x) * 0.05;

        // --- LIMITE SUAVE DO PAN (Botão Direito) ---
        // Suavizamos a transição do próprio limite para não haver saltos
        const targetLimit = isZoomedIn ? 14 : 4;
        currentPanLimit = THREE.MathUtils.lerp(currentPanLimit, targetLimit, 0.05);

        if (!isAnimating && Math.abs(controls.target.x) > currentPanLimit) {
            const overflow = controls.target.x - (controls.target.x > 0 ? currentPanLimit : -currentPanLimit);
            const correction = overflow * 0.05; 
            camera.position.x -= correction;
            controls.target.x -= correction;
        }

        // --- SOFT LIMITS & ADAPTIVE RESISTANCE (ROTATION ONLY) ---
        if (isAnimating) {
            controls.update();
            renderer.render(scene, camera);
            return;
        }
        // (O pan horizontal agora é limitado de forma rígida no listener de change)

        // 2. Rotação Horizontal (Azimuth) Resistance & Rubber-band
        const softAzimuthLimit = Math.PI / 15; 
        const currentAzimuth = controls.getAzimuthalAngle();

        // Calcular fator de velocidade (abrandar assim que ultrapassa o soft limit)
        let azimuthSpeedFactor = 1.0;
        if (Math.abs(currentAzimuth) > softAzimuthLimit) {
            const overflow = Math.abs(currentAzimuth) - softAzimuthLimit;
            const maxOverflow = Math.PI / 10; // Quão longe permitimos ir antes de parar total
            azimuthSpeedFactor = Math.max(0.01, 1.0 - (overflow / maxOverflow));
        }

        // 3. Rotação Vertical (Polar) Resistance & Rubber-band
        const softPolarMin = Math.PI / 6;
        const softPolarMax = Math.PI / 2.2;
        const currentPolar = controls.getPolarAngle();

        let polarSpeedFactor = 1.0;
        if (currentPolar < softPolarMin) {
            const overflow = softPolarMin - currentPolar;
            const maxOverflow = Math.PI / 15;
            polarSpeedFactor = Math.max(0.01, 1.0 - (overflow / maxOverflow));
        } else if (currentPolar > softPolarMax) {
            const overflow = currentPolar - softPolarMax;
            const maxOverflow = Math.PI / 15;
            polarSpeedFactor = Math.max(0.01, 1.0 - (overflow / maxOverflow));
        }

        // Aplicar a velocidade de rotação (alinhado com o eixo mais condicionado)
        controls.rotateSpeed = 1.0 * Math.min(azimuthSpeedFactor, polarSpeedFactor);

        // --- RUBBER-BAND ROTATION (Versão com Interpolação de Ângulos) ---
        const idealAzimuth = Math.max(-softAzimuthLimit, Math.min(softAzimuthLimit, currentAzimuth));
        const idealPolar = Math.max(softPolarMin, Math.min(softPolarMax, currentPolar));

        if (currentAzimuth !== idealAzimuth || currentPolar !== idealPolar) {
            // Em vez de fazermos lerp na posição (que corta caminho pelo interior),
            // fazemos lerp nos próprios ângulos. Isto mantém a distância perfeita.
            const lerpAzimuth = THREE.MathUtils.lerp(currentAzimuth, idealAzimuth, 0.08);
            const lerpPolar = THREE.MathUtils.lerp(currentPolar, idealPolar, 0.08);
            
            const distance = camera.position.distanceTo(controls.target);
            const nextPos = new THREE.Vector3();
            nextPos.setFromSphericalCoords(distance, lerpPolar, lerpAzimuth);
            nextPos.add(controls.target); 
            
            camera.position.copy(nextPos);
        }

        controls.update(); 
        renderer.render(scene, camera);
    }
    animate();

    // --- SCROLL ANIMATION ---
    // Revelação suave do piano com o scroll
    gsap.fromTo(container, 
        { 
            opacity: 0, 
            y: 150,
            scale: 0.9,
            filter: "blur(10px)"
        },
        {
            opacity: 1,
            y: 0,
            scale: 1,
            filter: "blur(0px)",
            duration: 2,
            ease: "power3.out",
            scrollTrigger: {
                trigger: container,
                start: "top 95%",
                end: "top 60%",
                scrub: 1, // Faz com que o "aparecer" acompanhe o scroll suavemente
            }
        }
    );

    // Revelação da Luz (Dramatic effect)
    gsap.from(spotLight, {
        intensity: 0,
        scrollTrigger: {
            trigger: container,
            start: "top 90%",
            end: "top 50%",
            scrub: true,
        }
    });

    // --- DOUBLE CLICK ZOOM ---
    const zoomOutPos = { x: 0, y: 30, z: 30 };
    const zoomInPos = { x: 0, y: 10, z: 10 };

    container.addEventListener('dblclick', () => {
        isZoomedIn = !isZoomedIn;
        isAnimating = true; // Bloqueia correções manuais durante o movimento do GSAP
        
        const targetPos = isZoomedIn ? zoomInPos : zoomOutPos;

        gsap.to(camera.position, {
            x: targetPos.x,
            y: targetPos.y,
            z: targetPos.z,
            duration: 1.5,
            ease: "power2.inOut",
            onComplete: () => { isAnimating = false; }
        });

        if (!isZoomedIn) {
            gsap.to(controls.target, {
                x: 0,
                y: 0,
                z: 0,
                duration: 1.5,
                ease: "power2.inOut"
            });
        }
    });

    // --- 7. PIANO PLAYER LOGIC ---
    function pressKey(key: THREE.Object3D) {
        if (!key || key.userData.isPressed) return;
        key.userData.isPressed = true;
        
        gsap.to(key.rotation, {
            x: 0.04,
            duration: 0.1,
            ease: "power2.out",
            onComplete: () => {
                gsap.to(key.rotation, {
                    x: 0,
                    duration: 0.2,
                    ease: "power2.inOut",
                    delay: 0.1,
                    onComplete: () => {
                        key.userData.isPressed = false;
                    }
                });
            }
        });
    }

    function playPiece(piece: any[]) {
        piece.forEach(event => {
            setTimeout(() => {
                const keyIndex = typeof event.key === 'string' ? (PIANO_KEYS as any)[event.key] : event.key;
                const key = allKeys[keyIndex];
                if (key) pressKey(key);
            }, event.time);
        });
    }

    // Ouvir eventos externos para tocar peças específicas
    window.addEventListener('piano:playPiece', (e: any) => {
        if (e.detail) playPiece(e.detail);
    });

    const resizeObserver = new ResizeObserver(() => {
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
    });
    resizeObserver.observe(container);
</script>