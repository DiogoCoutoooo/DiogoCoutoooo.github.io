---
// src/components/ThreeScene.astro
---
<div id="three-canvas-container"></div>

<style>
    #three-canvas-container {
        width: 100%;
        height: 100%;
        min-height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }
</style>

<script>
    import * as THREE from 'three';

    const container = document.getElementById('three-canvas-container')!;
    let width = container.clientWidth;
    let height = container.clientHeight;

    // --- 1. SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0d0d0d, 0.02);

    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(0, 15, 20);
    camera.lookAt(0, 0, -5);

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    // --- 2. LIGHTS ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); 
    scene.add(ambientLight);

    const spotLight = new THREE.SpotLight(0xddeeff, 10);
    spotLight.position.set(-10, 20, 10);
    spotLight.angle = Math.PI / 6;
    spotLight.penumbra = 0.5;
    spotLight.castShadow = true;
    spotLight.shadow.bias = -0.0001;
    scene.add(spotLight);

    const fillLight = new THREE.PointLight(0xffaa00, 2);
    fillLight.position.set(10, 5, 10);
    scene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0xffffff, 1);
    rimLight.position.set(0, 10, -10);
    scene.add(rimLight);

    // --- 3. MATERIALS ---
    const baseMat = new THREE.MeshPhongMaterial({ 
        color: 0x050505,
        emissive: 0x111111,
        specular: 0x555555,
        shininess: 30,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
    });

    const wireframeMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });

    const caseMat = new THREE.MeshPhysicalMaterial({
        color: 0x050505,
        roughness: 0.2,
        metalness: 0.8,
        clearcoat: 0.5,
    });

    const feltMat = new THREE.MeshBasicMaterial({ color: 0x050505 });

    // --- 4. KEYBOARD GROUP ---
    const keyboardGroup = new THREE.Group();
    scene.add(keyboardGroup);

    // --- 5. CONFIGURATION ---
    const NUM_WHITE_KEYS = 52; // Standard for 88 keys
    const GAP = 0.04;
    
    // White Keys
    const WHITE_KEY_WIDTH = 1.0; 
    const WHITE_KEY_HEIGHT = 1.0;
    const WHITE_KEY_LENGTH_FRONT = 2.2; 
    const WHITE_KEY_LENGTH_BACK = 4.4;  
    const WHITE_KEY_LENGTH_TOTAL = WHITE_KEY_LENGTH_FRONT + WHITE_KEY_LENGTH_BACK;
    
    const LIP_THICKNESS = 0.08; 
    const LIP_DEPTH = 0.07; 

    // Black Keys
    const BLACK_KEY_WIDTH = 0.52;
    const BLACK_KEY_LENGTH = 3.75;
    const BLACK_KEY_HEIGHT = 0.55; 
    const BLACK_KEY_CUTOUT_WIDTH = 0.6; // For the notch in white keys
    // Helper para as Brancas
    function createKeyShape(type: number, frontOffset = 0, isFirst = false, isLast = false) {
        const shape = new THREE.Shape();
        const w = WHITE_KEY_WIDTH - GAP;
        const cutoutW = BLACK_KEY_CUTOUT_WIDTH;
        
        let cL = 0, cR = 0; 
        
        // Se for a primeira tecla (A0), não tem recorte à esquerda
        // Se for a última (C8), não tem recorte à direita
        if (!isFirst && !isLast) {
            switch(type) {
                case 0: case 3: cR = cutoutW * 0.6; break;
                case 2: case 6: cL = cutoutW * 0.6; break;
                case 1: cL = cutoutW * 0.35; cR = cutoutW * 0.35; break;
                case 4: cL = cutoutW * 0.3; cR = cutoutW * 0.45; break;
                case 5: cL = cutoutW * 0.45; cR = cutoutW * 0.3; break;
            }
        } else if (isFirst) {
            // A0: Só tem recorte à direita para o A#0
            cR = cutoutW * 0.6; 
        } else if (isLast) {
            // C8: Não tem recortes (é uma tecla retangular no topo)
            // Mantemos cL e cR em 0
        }

        shape.moveTo(0, frontOffset);
        shape.lineTo(w, frontOffset);
        shape.lineTo(w, WHITE_KEY_LENGTH_FRONT);
        shape.lineTo(w - cR, WHITE_KEY_LENGTH_FRONT);
        shape.lineTo(w - cR, WHITE_KEY_LENGTH_TOTAL);
        shape.lineTo(cL, WHITE_KEY_LENGTH_TOTAL);
        shape.lineTo(cL, WHITE_KEY_LENGTH_FRONT);
        shape.lineTo(0, WHITE_KEY_LENGTH_FRONT);
        shape.lineTo(0, frontOffset);
        return shape;
    }

    function createWhiteKeyGroup(type: number, isFirst = false, isLast = false) {
        const group = new THREE.Group();
        const bodyH = WHITE_KEY_HEIGHT - LIP_THICKNESS;

        const bodyGeo = new THREE.ExtrudeGeometry(createKeyShape(type, LIP_DEPTH, isFirst, isLast), { steps: 1, depth: bodyH + 0.02, bevelEnabled: false });
        bodyGeo.rotateX(-Math.PI / 2);
        const bodyMesh = new THREE.Mesh(bodyGeo, baseMat);
        bodyMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(bodyGeo), wireframeMat));
        group.add(bodyMesh);

        const topGeo = new THREE.ExtrudeGeometry(createKeyShape(type, 0, isFirst, isLast), { steps: 1, depth: LIP_THICKNESS, bevelEnabled: false });
        topGeo.rotateX(-Math.PI / 2);
        topGeo.translate(0, bodyH, 0);
        const topMesh = new THREE.Mesh(topGeo, baseMat);
        topMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(topGeo), wireframeMat));
        group.add(topMesh);

        return group;
    }

    // --- BLACK KEY ---
    function createBlackKey() {
        const shape = new THREE.Shape();
        const r = 0.06; 
        const hW = BLACK_KEY_WIDTH / 2;
        const hL = BLACK_KEY_LENGTH / 2;

        shape.moveTo(-hW, hL);
        shape.lineTo(hW, hL);
        shape.lineTo(hW, -hL + r);
        shape.quadraticCurveTo(hW, -hL, hW - r, -hL);
        shape.lineTo(-hW + r, -hL);
        shape.quadraticCurveTo(-hW, -hL, -hW, -hL + r);
        shape.lineTo(-hW, hL);

        const geo = new THREE.ExtrudeGeometry(shape, { depth: BLACK_KEY_HEIGHT, bevelEnabled: false, steps: 1 });
        geo.rotateX(-Math.PI / 2);

        const pos = geo.attributes.position;
        const slopeX = 0.1; 
        const slopeZ = 0.3; 

        for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i);
            const y = pos.getY(i);
            const z = pos.getZ(i);
            const t = Math.max(0, Math.min(1, y / BLACK_KEY_HEIGHT));

            const taperFactor = 1.0 - (t * 0.35);
            pos.setX(i, x * taperFactor);

            if (z > -1.0) { 
                pos.setZ(i, z - t * slopeZ);
            }
        }
        geo.computeVertexNormals();

        const mesh = new THREE.Mesh(geo, baseMat);
        mesh.position.set(0, WHITE_KEY_HEIGHT, -BLACK_KEY_LENGTH/2 - WHITE_KEY_LENGTH_FRONT);
        mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo, 20), wireframeMat));
        
        return mesh;
    }

    const TOTAL_WIDTH = NUM_WHITE_KEYS * WHITE_KEY_WIDTH;

    // Adjustments for black key centering on the seams
    const blackKeyAdjustments: Record<number, number> = {
        1: -0.09, // C#
        2:  0.07, // D#
        4: -0.1,  // F#
        5: -0.01, // G#
        6:  0.07  // A#
    };

    for (let i = 0; i < NUM_WHITE_KEYS; i++) {
        const isFirst = (i === 0);
        const isLast = (i === NUM_WHITE_KEYS - 1);
        
        const noteIndex = (i + 5) % 7;
        const xPos = (i * WHITE_KEY_WIDTH) - (TOTAL_WIDTH / 2);

        // Place White Key
        const wk = createWhiteKeyGroup(noteIndex, isFirst, isLast);
        wk.position.set(xPos, 0, 0);
        keyboardGroup.add(wk);

        // Place Black Key if applicable
        const hasBlackKeyAfter = [5, 0, 1, 3, 4].includes(noteIndex);
        if (hasBlackKeyAfter && !isLast) {
            const bk = createBlackKey();
            const bkIndex = noteIndex + 1;
            const shift = blackKeyAdjustments[bkIndex] || 0;
            bk.position.x = xPos + WHITE_KEY_WIDTH + shift;
            keyboardGroup.add(bk);
        }
    }

    // --- Case / Frame Parts ---
    const blockWidth = 2.5;
    const blockGeo = new THREE.BoxGeometry(blockWidth, WHITE_KEY_HEIGHT + 0.5, WHITE_KEY_LENGTH_TOTAL + 2);
    const leftBlock = new THREE.Mesh(blockGeo, caseMat);
    leftBlock.position.set(-TOTAL_WIDTH/2 - blockWidth/2, 0.25, -WHITE_KEY_LENGTH_TOTAL/2 + 0.5);
    const rightBlock = new THREE.Mesh(blockGeo, caseMat);
    rightBlock.position.set(TOTAL_WIDTH/2 + blockWidth/2 - GAP, 0.25, -WHITE_KEY_LENGTH_TOTAL/2 + 0.5);
    keyboardGroup.add(leftBlock, rightBlock);

    const keyslipGeo = new THREE.BoxGeometry(TOTAL_WIDTH + blockWidth * 2, 1.0, 0.5);
    const keyslip = new THREE.Mesh(keyslipGeo, caseMat);
    keyslip.position.set(-0.35, -0.4, 0.25);
    keyboardGroup.add(keyslip);

    const fallboardGeo = new THREE.BoxGeometry(TOTAL_WIDTH + blockWidth * 2, 4, 1);
    const fallboard = new THREE.Mesh(fallboardGeo, caseMat);
    fallboard.position.set(-0.35, 2, -WHITE_KEY_LENGTH_TOTAL - 0.5);
    keyboardGroup.add(fallboard);
    
    const feltGeo = new THREE.BoxGeometry(TOTAL_WIDTH, 0.1, 0.5);
    const felt = new THREE.Mesh(feltGeo, feltMat);
    felt.position.set(-WHITE_KEY_WIDTH/2, WHITE_KEY_HEIGHT, -WHITE_KEY_LENGTH_TOTAL + 0.2);
    keyboardGroup.add(felt);

    // --- ANIMATION ---
    // const mouse = { x: 0, y: 0 };
    // window.addEventListener('mousemove', (e) => {
    //     mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    //     mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    // });

    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        keyboardGroup.position.y = Math.sin(time * 0.5) * 0.2;
        // keyboardGroup.rotation.y += (mouse.x * 1.3 - keyboardGroup.rotation.y) * 0.05;
        // keyboardGroup.rotation.x += (mouse.y * 0.7 - keyboardGroup.rotation.x) * 0.05;
        renderer.render(scene, camera);
    }
    animate();

    const resizeObserver = new ResizeObserver(() => {
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
    });
    resizeObserver.observe(container);
</script>